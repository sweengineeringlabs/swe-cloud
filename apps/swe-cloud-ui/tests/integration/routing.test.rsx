//! Routing integration tests.
//!
//! Tests route configuration and resolution.
//! Generated by `rsc scaffold routes`

use rustscript::test::*;
use rustscript::router::{Router, RouteMatch};

#[integration]
fn router_resolves_all_routes() {
    let router = Router::from_config();

    // Verify all routes are registered
    assert!(router.route_count() > 0);
}

#[integration]
fn router_handles_not_found() {
    let router = Router::from_config();
    let result = router.resolve("/nonexistent-path-xyz");

    assert!(result.is_none() || result.unwrap().is_not_found());
}

#[integration]
fn router_resolves_root() {
    let router = Router::from_config();
    let result = router.resolve("/");

    assert!(result.is_some());
}

#[integration]
fn router_resolves_dashboard() {
    let router = Router::from_config();
    let result = router.resolve("/");

    assert!(result.is_some(), "Route / should be resolvable");
}

#[integration]
fn router_resolves_cloudemu_overview() {
    let router = Router::from_config();
    let result = router.resolve("/cloudemu");

    assert!(result.is_some(), "Route /cloudemu should be resolvable");
}

#[integration]
fn router_resolves_cloudkit_overview() {
    let router = Router::from_config();
    let result = router.resolve("/cloudkit");

    assert!(result.is_some(), "Route /cloudkit should be resolvable");
}

#[integration]
fn router_resolves_iac_overview() {
    let router = Router::from_config();
    let result = router.resolve("/iac");

    assert!(result.is_some(), "Route /iac should be resolvable");
}

#[integration]
fn router_resolves_settings_index() {
    let router = Router::from_config();
    let result = router.resolve("/settings");

    assert!(result.is_some(), "Route /settings should be resolvable");
}

#[integration]
fn router_resolves_not_found() {
    let router = Router::from_config();
    let result = router.resolve("*");

    assert!(result.is_some(), "Route * should be resolvable");
}

