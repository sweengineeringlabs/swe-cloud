(function(global){'use strict';class HandleManager{constructor(){this.handles=new Map();this.nextId=1;}alloc(obj){const id=this.nextId++;this.handles.set(id,obj);return id;}get(id){return this.handles.get(id);}free(id){return this.handles.delete(id);}has(id){return this.handles.has(id);}}
const elementHandles=new HandleManager();const eventHandlerHandles=new HandleManager();const timerHandles=new HandleManager();let wasmInstance=null;let wasmMemory=null;function readString(ptr,len){const bytes=new Uint8Array(wasmMemory.buffer,ptr,len);return new TextDecoder().decode(bytes);}function writeString(str,ptr,maxLen){const bytes=new TextEncoder().encode(str);const len=Math.min(bytes.length,maxLen);const view=new Uint8Array(wasmMemory.buffer,ptr,len);view.set(bytes.subarray(0,len));return len;}
const dom={getElementById(idPtr,idLen){const id=readString(idPtr,idLen);const element=document.getElementById(id);if(element){return elementHandles.alloc(element);}return 0;},querySelector(selectorPtr,selectorLen){const selector=readString(selectorPtr,selectorLen);const element=document.querySelector(selector);if(element){return elementHandles.alloc(element);}return 0;},createElement(tagPtr,tagLen){const tag=readString(tagPtr,tagLen);const element=document.createElement(tag);return elementHandles.alloc(element);},createElementNS(nsPtr,nsLen,tagPtr,tagLen){const namespaceURI=readString(nsPtr,nsLen);const tag=readString(tagPtr,tagLen);const element=document.createElementNS(namespaceURI,tag);return elementHandles.alloc(element);},createTextNode(textPtr,textLen){const text=readString(textPtr,textLen);const node=document.createTextNode(text);return elementHandles.alloc(node);},setAttribute(handle,namePtr,nameLen,valuePtr,valueLen){const element=elementHandles.get(handle);if(element&&element.setAttribute){const name=readString(namePtr,nameLen);const value=readString(valuePtr,valueLen);element.setAttribute(name,value);}},getAttribute(handle,namePtr,nameLen,outPtr,outLen){const element=elementHandles.get(handle);if(element&&element.getAttribute){const name=readString(namePtr,nameLen);const value=element.getAttribute(name);if(value!==null){return writeString(value,outPtr,outLen);}}return-1;},removeAttribute(handle,namePtr,nameLen){const element=elementHandles.get(handle);if(element&&element.removeAttribute){const name=readString(namePtr,nameLen);element.removeAttribute(name);}},setTextContent(handle,textPtr,textLen){const element=elementHandles.get(handle);if(element){element.textContent=readString(textPtr,textLen);}},getTextContent(handle,outPtr,outLen){const element=elementHandles.get(handle);if(element){const text=element.textContent||'';return writeString(text,outPtr,outLen);}return 0;},setInnerHTML(handle,htmlPtr,htmlLen){const element=elementHandles.get(handle);if(element){element.innerHTML=readString(htmlPtr,htmlLen);}},appendChild(parentHandle,childHandle){const parent=elementHandles.get(parentHandle);const child=elementHandles.get(childHandle);if(parent&&child){parent.appendChild(child);}},insertBefore(parentHandle,newHandle,refHandle){const parent=elementHandles.get(parentHandle);const newNode=elementHandles.get(newHandle);const refNode=refHandle?elementHandles.get(refHandle):null;if(parent&&newNode){parent.insertBefore(newNode,refNode);}},removeChild(parentHandle,childHandle){const parent=elementHandles.get(parentHandle);const child=elementHandles.get(childHandle);if(parent&&child&&child.parentNode===parent){parent.removeChild(child);}},remove(handle){const element=elementHandles.get(handle);if(element&&element.remove){element.remove();}},cloneNode(handle,deep){const element=elementHandles.get(handle);if(element){const clone=element.cloneNode(!!deep);return elementHandles.alloc(clone);}return 0;},getParent(handle){const element=elementHandles.get(handle);if(element&&element.parentElement){return elementHandles.alloc(element.parentElement);}return 0;},getFirstChild(handle){const element=elementHandles.get(handle);if(element&&element.firstChild){return elementHandles.alloc(element.firstChild);}return 0;},getNextSibling(handle){const element=elementHandles.get(handle);if(element&&element.nextSibling){return elementHandles.alloc(element.nextSibling);}return 0;},addClass(handle,classPtr,classLen){const element=elementHandles.get(handle);if(element&&element.classList){element.classList.add(readString(classPtr,classLen));}},removeClass(handle,classPtr,classLen){const element=elementHandles.get(handle);if(element&&element.classList){element.classList.remove(readString(classPtr,classLen));}},toggleClass(handle,classPtr,classLen){const element=elementHandles.get(handle);if(element&&element.classList){return element.classList.toggle(readString(classPtr,classLen))?1:0;}return 0;},hasClass(handle,classPtr,classLen){const element=elementHandles.get(handle);if(element&&element.classList){return element.classList.contains(readString(classPtr,classLen))?1:0;}return 0;},setStyle(handle,propPtr,propLen,valuePtr,valueLen){const element=elementHandles.get(handle);if(element&&element.style){const prop=readString(propPtr,propLen);const value=readString(valuePtr,valueLen);element.style.setProperty(prop,value);}},getBoundingClientRect(handle,outPtr){const element=elementHandles.get(handle);if(element&&element.getBoundingClientRect){const rect=element.getBoundingClientRect();const view=new Float64Array(wasmMemory.buffer,outPtr,8);view[0]=rect.x;view[1]=rect.y;view[2]=rect.width;view[3]=rect.height;view[4]=rect.top;view[5]=rect.right;view[6]=rect.bottom;view[7]=rect.left;}},focus(handle){const element=elementHandles.get(handle);if(element&&element.focus){element.focus();}},blur(handle){const element=elementHandles.get(handle);if(element&&element.blur){element.blur();}},getValue(handle,outPtr,outLen){const element=elementHandles.get(handle);if(element&&'value'in element){return writeString(element.value,outPtr,outLen);}return 0;},setValue(handle,valuePtr,valueLen){const element=elementHandles.get(handle);if(element&&'value'in element){element.value=readString(valuePtr,valueLen);}},getChecked(handle){const element=elementHandles.get(handle);if(element&&'checked'in element){return element.checked?1:0;}return 0;},setChecked(handle,checked){const element=elementHandles.get(handle);if(element&&'checked'in element){element.checked=!!checked;}},freeElement(handle){elementHandles.free(handle);},getBody(){return elementHandles.alloc(document.body);},getHead(){return elementHandles.alloc(document.head);},getDocumentElement(){return elementHandles.alloc(document.documentElement);}};let activeEventId=0;const activeEvents=new Map();const events={createHandler(callbackId){const handler={callbackId};return eventHandlerHandles.alloc(handler);},addEventListenerDirect(targetHandle,eventTypePtr,eventTypeLen,callbackId){const target=elementHandles.get(targetHandle);if(!target)return;const eventType=readString(eventTypePtr,eventTypeLen);const listener=(event)=>{const eventId=++activeEventId;activeEvents.set(eventId,event);try{const eventData=packageEvent(event,eventType);if(wasmInstance&&wasmInstance.exports.__rsc_handle_event){wasmInstance.exports.__rsc_handle_event(callbackId,eventId,eventData);}}finally{activeEvents.delete(eventId);}};target.addEventListener(eventType,listener,{capture:false,once:false,passive:false});const handler={callbackId,listener,eventType,target};return eventHandlerHandles.alloc(handler);},addEventListener(targetHandle,eventTypePtr,eventTypeLen,handlerHandle,capture,once,passive){const target=elementHandles.get(targetHandle);const handler=eventHandlerHandles.get(handlerHandle);if(!target||!handler)return;const eventType=readString(eventTypePtr,eventTypeLen);const callbackId=handler.callbackId;const listener=(event)=>{const eventId=++activeEventId;activeEvents.set(eventId,event);try{const eventData=packageEvent(event,eventType);if(wasmInstance&&wasmInstance.exports.__rsc_handle_event){wasmInstance.exports.__rsc_handle_event(callbackId,eventId,eventData);}}finally{activeEvents.delete(eventId);}};handler.listener=listener;handler.eventType=eventType;handler.target=target;target.addEventListener(eventType,listener,{capture:!!capture,once:!!once,passive:!!passive});},removeEventListener(targetHandle,eventTypePtr,eventTypeLen,handlerHandle){const target=elementHandles.get(targetHandle);const handler=eventHandlerHandles.get(handlerHandle);if(!target||!handler||!handler.listener)return;const eventType=readString(eventTypePtr,eventTypeLen);target.removeEventListener(eventType,handler.listener);handler.listener=null;},preventDefault(eventId){const event=activeEvents.get(eventId);if(event&&event.cancelable){event.preventDefault();}},stopPropagation(eventId){const event=activeEvents.get(eventId);if(event){event.stopPropagation();}},stopImmediatePropagation(eventId){const event=activeEvents.get(eventId);if(event){event.stopImmediatePropagation();}},freeHandler(handle){const handler=eventHandlerHandles.get(handle);if(handler&&handler.listener&&handler.target){handler.target.removeEventListener(handler.eventType,handler.listener);}eventHandlerHandles.free(handle);}};function packageEvent(event,eventType){const base={type:eventType,timestamp:event.timeStamp,bubbles:event.bubbles,cancelable:event.cancelable,phase:event.eventPhase,isTrusted:event.isTrusted};if(event instanceof MouseEvent){return{...base,kind:'mouse',clientX:event.clientX,clientY:event.clientY,pageX:event.pageX,pageY:event.pageY,screenX:event.screenX,screenY:event.screenY,offsetX:event.offsetX,offsetY:event.offsetY,button:event.button,buttons:event.buttons,altKey:event.altKey,ctrlKey:event.ctrlKey,metaKey:event.metaKey,shiftKey:event.shiftKey};}if(event instanceof KeyboardEvent){return{...base,kind:'keyboard',key:event.key,code:event.code,keyCode:event.keyCode,repeat:event.repeat,altKey:event.altKey,ctrlKey:event.ctrlKey,metaKey:event.metaKey,shiftKey:event.shiftKey,location:event.location};}if(event instanceof FocusEvent){return{...base,kind:'focus'};}if(event instanceof InputEvent){return{...base,kind:'input',data:event.data,inputType:event.inputType,isComposing:event.isComposing};}return{...base,kind:'generic'};}
const consoleApi={log(msgPtr,msgLen){console.log(readString(msgPtr,msgLen));},warn(msgPtr,msgLen){console.warn(readString(msgPtr,msgLen));},error(msgPtr,msgLen){console.error(readString(msgPtr,msgLen));},debug(msgPtr,msgLen){console.debug(readString(msgPtr,msgLen));},info(msgPtr,msgLen){console.info(readString(msgPtr,msgLen));},group(labelPtr,labelLen){console.group(readString(labelPtr,labelLen));},groupCollapsed(labelPtr,labelLen){console.groupCollapsed(readString(labelPtr,labelLen));},groupEnd(){console.groupEnd();},time(labelPtr,labelLen){console.time(readString(labelPtr,labelLen));},timeEnd(labelPtr,labelLen){console.timeEnd(readString(labelPtr,labelLen));},timeLog(labelPtr,labelLen){console.timeLog(readString(labelPtr,labelLen));},clear(){console.clear();}};const timers={setTimeout(callbackId,delay){const nativeId=setTimeout(()=>{if(wasmInstance&&wasmInstance.exports.__rsc_handle_timer){wasmInstance.exports.__rsc_handle_timer(callbackId);}},delay);return timerHandles.alloc({nativeId,type:'timeout'});},clearTimeout(handle){const timer=timerHandles.get(handle);if(timer&&timer.type==='timeout'){clearTimeout(timer.nativeId);timerHandles.free(handle);}},setInterval(callbackId,interval){const nativeId=setInterval(()=>{if(wasmInstance&&wasmInstance.exports.__rsc_handle_timer){wasmInstance.exports.__rsc_handle_timer(callbackId);}},interval);return timerHandles.alloc({nativeId,type:'interval'});},clearInterval(handle){const timer=timerHandles.get(handle);if(timer&&timer.type==='interval'){clearInterval(timer.nativeId);timerHandles.free(handle);}},requestAnimationFrame(callbackId){const nativeId=requestAnimationFrame((timestamp)=>{if(wasmInstance&&wasmInstance.exports.__rsc_handle_animation_frame){wasmInstance.exports.__rsc_handle_animation_frame(callbackId,timestamp);}});return timerHandles.alloc({nativeId,type:'raf'});},cancelAnimationFrame(handle){const timer=timerHandles.get(handle);if(timer&&timer.type==='raf'){cancelAnimationFrame(timer.nativeId);timerHandles.free(handle);}},now(){return performance.now();}};const storage={localStorageGet(keyPtr,keyLen,outPtr,outLen){const key=readString(keyPtr,keyLen);const value=localStorage.getItem(key);if(value!==null){return writeString(value,outPtr,outLen);}return-1;},localStorageSet(keyPtr,keyLen,valuePtr,valueLen){try{const key=readString(keyPtr,keyLen);const value=readString(valuePtr,valueLen);localStorage.setItem(key,value);return 1;}catch(e){return 0;}},localStorageRemove(keyPtr,keyLen){const key=readString(keyPtr,keyLen);localStorage.removeItem(key);},localStorageClear(){localStorage.clear();},localStorageLength(){return localStorage.length;},localStorageKey(index,outPtr,outLen){const key=localStorage.key(index);if(key!==null){return writeString(key,outPtr,outLen);}return-1;},localStorageKeys(outPtr,outLen){const keys=[];for(let i=0;i<localStorage.length;i++){keys.push(localStorage.key(i));}const json=JSON.stringify(keys);return writeString(json,outPtr,outLen);},sessionStorageGet(keyPtr,keyLen,outPtr,outLen){const key=readString(keyPtr,keyLen);const value=sessionStorage.getItem(key);if(value!==null){return writeString(value,outPtr,outLen);}return-1;},sessionStorageSet(keyPtr,keyLen,valuePtr,valueLen){try{const key=readString(keyPtr,keyLen);const value=readString(valuePtr,valueLen);sessionStorage.setItem(key,value);return 1;}catch(e){return 0;}},sessionStorageRemove(keyPtr,keyLen){const key=readString(keyPtr,keyLen);sessionStorage.removeItem(key);},sessionStorageClear(){sessionStorage.clear();},sessionStorageLength(){return sessionStorage.length;},sessionStorageKey(index,outPtr,outLen){const key=sessionStorage.key(index);if(key!==null){return writeString(key,outPtr,outLen);}return-1;},sessionStorageKeys(outPtr,outLen){const keys=[];for(let i=0;i<sessionStorage.length;i++){keys.push(sessionStorage.key(i));}const json=JSON.stringify(keys);return writeString(json,outPtr,outLen);}};const pendingFetches=new Map();const requestBuilders=new HandleManager();let nextFetchId=1;const HTTP_METHODS=['GET','POST','PUT','PATCH','DELETE','HEAD','OPTIONS'];const REQUEST_MODES=['cors','no-cors','same-origin'];const CREDENTIALS_MODES=['omit','same-origin','include'];const CACHE_MODES=['default','no-store','reload','no-cache','force-cache','only-if-cached'];const REDIRECT_MODES=['follow','error','manual'];const REFERRER_POLICIES=['no-referrer','no-referrer-when-downgrade','same-origin','origin','strict-origin','origin-when-cross-origin','strict-origin-when-cross-origin','unsafe-url'];const RESPONSE_TYPES=['basic','cors','default','error','opaque','opaqueredirect'];const FETCH_ERROR_KINDS={NETWORK:0,TIMEOUT:1,ABORTED:2,CORS:3,INVALID_REQUEST:4,INVALID_URL:5};async function convertResponse(response){const bodyBytes=await response.arrayBuffer();const headers=[];response.headers.forEach((value,name)=>{headers.push({name,value});});let responseType=2;const rtIndex=RESPONSE_TYPES.indexOf(response.type);if(rtIndex!==-1){responseType=rtIndex;}return{status:response.status,statusText:response.statusText,headers:headers,body:new Uint8Array(bodyBytes),url:response.url,redirected:response.redirected,responseType:responseType};}function createFetchError(kind,message){return{kind,message};}async function performFetch(request){try{const options={method:HTTP_METHODS[request.method]||'GET',headers:new Headers(),mode:REQUEST_MODES[request.mode]||'cors',credentials:CREDENTIALS_MODES[request.credentials]||'same-origin',cache:CACHE_MODES[request.cache]||'default',redirect:REDIRECT_MODES[request.redirect]||'follow',referrerPolicy:REFERRER_POLICIES[request.referrerPolicy]||'strict-origin-when-cross-origin'};if(request.headers&&Array.isArray(request.headers)){request.headers.forEach(h=>{options.headers.append(h.name,h.value);});}
if(request.body&&request.body.length>0){options.body=new Uint8Array(request.body);}
let abortController=null;let timeoutId=null;if(request.timeoutMs>0){abortController=new AbortController();options.signal=abortController.signal;timeoutId=setTimeout(()=>{abortController.abort();},request.timeoutMs);}try{const response=await fetch(request.url,options);if(timeoutId)clearTimeout(timeoutId);return{ok:true,value:await convertResponse(response)};}catch(error){if(timeoutId)clearTimeout(timeoutId);let errorKind=FETCH_ERROR_KINDS.NETWORK;if(error.name==='AbortError'){errorKind=FETCH_ERROR_KINDS.TIMEOUT;}else if(error.message&&error.message.includes('CORS')){errorKind=FETCH_ERROR_KINDS.CORS;}return{ok:false,error:createFetchError(errorKind,error.message||'Fetch failed')};}}catch(error){return{ok:false,error:createFetchError(FETCH_ERROR_KINDS.INVALID_REQUEST,error.message)};}}const http={async fetch(request){return performFetch(request);},async get(url){return performFetch({url:url,method:0,
headers:[],body:null,mode:0,credentials:1,cache:0,redirect:0,referrerPolicy:6,timeoutMs:0});},async post(url,body,contentType){return performFetch({url:url,method:1,
headers:[{name:'Content-Type',value:contentType}],body:Array.from(body),mode:0,credentials:1,cache:0,redirect:0,referrerPolicy:6,timeoutMs:0});},async postJson(url,json){return performFetch({url:url,method:1,
headers:[{name:'Content-Type',value:'application/json'}],body:Array.from(new TextEncoder().encode(json)),mode:0,credentials:1,cache:0,redirect:0,referrerPolicy:6,timeoutMs:0});},
'request-builder#constructor':function(url){const builder={url:url,method:0,
headers:[],body:null,mode:0,credentials:1,cache:0,redirect:0,referrerPolicy:6,timeoutMs:0};return requestBuilders.alloc(builder);},'request-builder#method':function(handle,method){const builder=requestBuilders.get(handle);if(builder){builder.method=method;}return handle;},'request-builder#header':function(handle,name,value){const builder=requestBuilders.get(handle);if(builder){builder.headers.push({name,value});}return handle;},'request-builder#body':function(handle,body){const builder=requestBuilders.get(handle);if(builder){builder.body=Array.from(body);}return handle;},'request-builder#json':function(handle,json){const builder=requestBuilders.get(handle);if(builder){builder.headers.push({name:'Content-Type',value:'application/json'});builder.body=Array.from(new TextEncoder().encode(json));}return handle;},'request-builder#form':function(handle,data){const builder=requestBuilders.get(handle);if(builder){builder.headers.push({name:'Content-Type',value:'application/x-www-form-urlencoded'});const formBody=data.map(([k,v])=>`${encodeURIComponent(k)}=${encodeURIComponent(v)}`).join('&');builder.body=Array.from(new TextEncoder().encode(formBody));}return handle;},'request-builder#mode':function(handle,mode){const builder=requestBuilders.get(handle);if(builder){builder.mode=mode;}return handle;},'request-builder#credentials':function(handle,credentials){const builder=requestBuilders.get(handle);if(builder){builder.credentials=credentials;}return handle;},'request-builder#timeout':function(handle,ms){const builder=requestBuilders.get(handle);if(builder){builder.timeoutMs=ms;}return handle;},'request-builder#send':async function(handle){const builder=requestBuilders.get(handle);if(!builder){return{ok:false,error:createFetchError(FETCH_ERROR_KINDS.INVALID_REQUEST,'Invalid builder handle')};}const result=await performFetch(builder);requestBuilders.free(handle);return result;},'request-builder#drop':function(handle){requestBuilders.free(handle);},
responseText(response){try{const text=new TextDecoder().decode(new Uint8Array(response.body));return{ok:true,value:text};}catch(error){return{ok:false,error:'Failed to decode response as UTF-8'};}},responseJson(response){try{const text=new TextDecoder().decode(new Uint8Array(response.body));JSON.parse(text);return{ok:true,value:text};}catch(error){return{ok:false,error:'Invalid JSON in response body'};}},
fetchLowLevel(urlPtr,urlLen,methodPtr,methodLen,bodyPtr,bodyLen){const url=readString(urlPtr,urlLen);const method=readString(methodPtr,methodLen);const body=bodyPtr?readString(bodyPtr,bodyLen):null;const fetchId=nextFetchId++;fetch(url,{method,body:body||undefined,}).then(async(response)=>{const responseData=await convertResponse(response);if(wasmInstance&&wasmInstance.exports.__rsc_handle_fetch_response){wasmInstance.exports.__rsc_handle_fetch_response(fetchId,responseData.status,response.ok?1:0,JSON.stringify(responseData));}}).catch((error)=>{if(wasmInstance&&wasmInstance.exports.__rsc_handle_fetch_error){wasmInstance.exports.__rsc_handle_fetch_error(fetchId,error.message);}});return fetchId;}};const popstateCallbacks=new Map();const hashchangeCallbacks=new Map();const router={getPathname(outPtr,outLen){return writeString(location.pathname,outPtr,outLen);},getSearch(outPtr,outLen){return writeString(location.search,outPtr,outLen);},getHash(outPtr,outLen){return writeString(location.hash,outPtr,outLen);},getHref(outPtr,outLen){return writeString(location.href,outPtr,outLen);},getOrigin(outPtr,outLen){return writeString(location.origin,outPtr,outLen);},pushState(urlPtr,urlLen,statePtr,stateLen){const url=readString(urlPtr,urlLen);let state=null;if(statePtr&&stateLen>0){try{state=JSON.parse(readString(statePtr,stateLen));}catch(e){}}history.pushState(state,'',url);},replaceState(urlPtr,urlLen,statePtr,stateLen){const url=readString(urlPtr,urlLen);let state=null;if(statePtr&&stateLen>0){try{state=JSON.parse(readString(statePtr,stateLen));}catch(e){}}history.replaceState(state,'',url);},goBack(){history.back();},goForward(){history.forward();},go(delta){history.go(delta);},getState(outPtr,outLen){if(history.state!==null){const stateJson=JSON.stringify(history.state);return writeString(stateJson,outPtr,outLen);}return-1;},historyLength(){return history.length;},setHash(hashPtr,hashLen){let hash=readString(hashPtr,hashLen);if(!hash.startsWith('#')){hash='#'+hash;}location.hash=hash;},onPopstate(callbackId){if(popstateCallbacks.has(callbackId)){return;}const handler=(event)=>{const navEvent={pathname:location.pathname,search:location.search,hash:location.hash,state:event.state?JSON.stringify(event.state):null};if(wasmInstance&&wasmInstance.exports.__rsc_handle_popstate){wasmInstance.exports.__rsc_handle_popstate(callbackId,JSON.stringify(navEvent));}};window.addEventListener('popstate',handler);popstateCallbacks.set(callbackId,handler);},onHashchange(callbackId){if(hashchangeCallbacks.has(callbackId)){return;}const handler=(event)=>{const navEvent={pathname:location.pathname,search:location.search,hash:location.hash,state:history.state?JSON.stringify(history.state):null,oldURL:event.oldURL,newURL:event.newURL};if(wasmInstance&&wasmInstance.exports.__rsc_handle_hashchange){wasmInstance.exports.__rsc_handle_hashchange(callbackId,JSON.stringify(navEvent));}};window.addEventListener('hashchange',handler);hashchangeCallbacks.set(callbackId,handler);},offPopstate(callbackId){const handler=popstateCallbacks.get(callbackId);if(handler){window.removeEventListener('popstate',handler);popstateCallbacks.delete(callbackId);}},offHashchange(callbackId){const handler=hashchangeCallbacks.get(callbackId);if(handler){window.removeEventListener('hashchange',handler);hashchangeCallbacks.delete(callbackId);}}};const componentManager={instances:new Map(),nextId:1,create(renderFn,props,parentElement){const componentId=this.nextId++;const parent=typeof parentElement==='number'?elementHandles.get(parentElement):parentElement;const instance={id:componentId,renderFn:renderFn,props:props||{},element:null,
signals:new Map(),
effects:new Map(),
children:new Map(),
parent:parent,parentId:null,
mounted:false,error:null};this.instances.set(componentId,instance);try{errorBoundary.push(componentId,null);const element=errorBoundary.wrapRender(()=>renderFn(props));errorBoundary.pop();if(element){instance.element=typeof element==='number'?elementHandles.get(element):element;if(parent&&instance.element){parent.appendChild(instance.element);}}instance.mounted=true;}catch(error){instance.error=error;errorBoundary.handleError(error);}return componentId;},update(componentId,newProps){const instance=this.instances.get(componentId);if(!instance){console.warn(`Component ${componentId} not found`);return false;}
const prevProps=instance.props;instance.props={...prevProps,...newProps};try{errorBoundary.push(componentId,null);const newElement=errorBoundary.wrapRender(()=>instance.renderFn(instance.props));errorBoundary.pop();if(newElement){const resolvedElement=typeof newElement==='number'?elementHandles.get(newElement):newElement;if(instance.element&&instance.element.parentNode){instance.element.parentNode.replaceChild(resolvedElement,instance.element);}instance.element=resolvedElement;}instance.error=null;return true;}catch(error){instance.error=error;errorBoundary.handleError(error);return false;}},unmount(componentId){const instance=this.instances.get(componentId);if(!instance){return false;}
for(const childId of instance.children.keys()){this.unmount(childId);}
for(const[effectId,effect]of instance.effects){if(effect.cleanup&&typeof effect.cleanup==='function'){try{effect.cleanup();}catch(e){console.error(`Error in effect cleanup for component ${componentId}:`,e);}}}instance.effects.clear();for(const[signalName,signal]of instance.signals){signal.subscribers.clear();}instance.signals.clear();if(instance.element&&instance.element.parentNode){instance.element.parentNode.removeChild(instance.element);}
if(instance.parentId){const parentInstance=this.instances.get(instance.parentId);if(parentInstance){parentInstance.children.delete(componentId);}}instance.mounted=false;this.instances.delete(componentId);return true;},get(componentId){return this.instances.get(componentId)||null;},addChild(parentId,childId){const parent=this.instances.get(parentId);const child=this.instances.get(childId);if(parent&&child){parent.children.set(childId,child);child.parentId=parentId;}},createSignal(componentId,name,initialValue){const instance=this.instances.get(componentId);if(!instance){throw new Error(`Component ${componentId} not found`);}const signal={value:initialValue,subscribers:new Set()};instance.signals.set(name,signal);return{get:()=>signal.value,set:(newValue)=>{const oldValue=signal.value;signal.value=newValue;for(const subscriber of signal.subscribers){try{subscriber(newValue,oldValue);}catch(e){console.error('Signal subscriber error:',e);}}},subscribe:(fn)=>{signal.subscribers.add(fn);return()=>signal.subscribers.delete(fn);}};},registerEffect(componentId,effectFn,deps){const instance=this.instances.get(componentId);if(!instance){throw new Error(`Component ${componentId} not found`);}const effectId=lifecycleManager.nextId++;const effect={fn:effectFn,deps:deps?[...deps]:null,cleanup:null};instance.effects.set(effectId,effect);queueMicrotask(()=>{try{const cleanup=effectFn();if(typeof cleanup==='function'){effect.cleanup=cleanup;}}catch(e){console.error(`Effect error in component ${componentId}:`,e);}});return effectId;},getAllIds(){return Array.from(this.instances.keys());},count(){return this.instances.size;}};const errorBoundary={boundaryStack:[],errorStates:new Map(),globalErrorHandler:null,push(componentId,fallbackFn){this.boundaryStack.push({componentId:componentId,fallback:fallbackFn,hasError:false,error:null});},pop(){return this.boundaryStack.pop()||null;},current(){return this.boundaryStack.length>0?this.boundaryStack[this.boundaryStack.length-1]:null;},handleError(error){const boundary=this.current();console.error('RustScript render error:',error);if(boundary){boundary.hasError=true;boundary.error=error;this.errorStates.set(boundary.componentId,{error:error,timestamp:Date.now()});if(this.globalErrorHandler){try{this.globalErrorHandler(error,boundary.componentId);}catch(e){console.error('Global error handler threw:',e);}}
if(boundary.fallback){try{return boundary.fallback(error,boundary.componentId);}catch(fallbackError){console.error('Error boundary fallback threw:',fallbackError);this.pop();return this.handleError(fallbackError);}}return null;}
if(this.globalErrorHandler){this.globalErrorHandler(error,null);}throw error;},wrapRender(renderFn){try{return renderFn();}catch(error){return this.handleError(error);}},hasError(componentId){return this.errorStates.has(componentId);},getError(componentId){return this.errorStates.get(componentId)||null;},clearError(componentId){this.errorStates.delete(componentId);},clearAllErrors(){this.errorStates.clear();},setGlobalErrorHandler(handler){this.globalErrorHandler=handler;},createBoundary(componentId,renderFn,fallbackFn){this.push(componentId,fallbackFn);const result=this.wrapRender(renderFn);this.pop();return result;},retry(componentId,renderFn){this.clearError(componentId);const instance=componentManager.get(componentId);if(instance){instance.error=null;}return this.wrapRender(renderFn);}};const reactivity={currentContext:null,
dependencies:new Map(),
pendingUpdates:new Set(),
flushScheduled:false,
batchDepth:0,
vdomCache:new WeakMap(),scheduleUpdate(updater){this.pendingUpdates.add(updater);if(!this.flushScheduled&&this.batchDepth===0){this.flushScheduled=true;queueMicrotask(()=>this.flush());}},flush(){this.flushScheduled=false;const updates=Array.from(this.pendingUpdates);this.pendingUpdates.clear();for(const updater of updates){try{updater();}catch(error){console.error('[RustScript Reactivity] Error in updater:',error);}}},startBatch(){this.batchDepth++;},endBatch(){this.batchDepth--;if(this.batchDepth===0&&this.pendingUpdates.size>0){this.flush();}},track(signalId){if(this.currentContext===null){return;}if(!this.dependencies.has(signalId)){this.dependencies.set(signalId,new Set());}this.dependencies.get(signalId).add(this.currentContext);},trigger(signalId){const deps=this.dependencies.get(signalId);if(!deps||deps.size===0){return;}for(const updater of deps){this.scheduleUpdate(updater);}},runInContext(fn,updater){const prevContext=this.currentContext;this.currentContext=updater;try{return fn();}finally{this.currentContext=prevContext;}},createEffect(fn){let cleanup=null;const run=()=>{if(cleanup&&typeof cleanup==='function'){cleanup();}
this.cleanupDependencies(run);cleanup=this.runInContext(fn,run);};run();return()=>{this.cleanupDependencies(run);if(cleanup&&typeof cleanup==='function'){cleanup();}};},cleanupDependencies(updater){for(const deps of this.dependencies.values()){deps.delete(updater);}},createComputed(getter){let value;let dirty=true;const computedId=Symbol('computed');const updater=()=>{dirty=true;this.trigger(computedId);};return{get:()=>{if(dirty){value=this.runInContext(getter,updater);dirty=false;}
this.track(computedId);return value;},id:computedId};},createSignal(initialValue){const signalId=Symbol('signal');let value=initialValue;return{get:()=>{this.track(signalId);return value;},set:(newValue)=>{if(value!==newValue){value=newValue;this.trigger(signalId);}},id:signalId};}};const vdom={text(text){return{type:'text',value:String(text)};},element(tag,attrs={},children=[]){return{type:'element',tag,attrs,children};},patchText(node,newText){const newTextStr=String(newText);if(node.textContent!==newTextStr){node.textContent=newTextStr;return true;}return false;},patchAttrs(element,oldAttrs,newAttrs){let updated=false;for(const key of Object.keys(oldAttrs)){if(!(key in newAttrs)){if(key.startsWith('on')){}else if(key==='style'&&typeof oldAttrs[key]==='object'){for(const prop of Object.keys(oldAttrs[key])){element.style.removeProperty(prop);}}else if(key==='class'||key==='className'){element.className='';}else{element.removeAttribute(key);}updated=true;}}
for(const[key,value]of Object.entries(newAttrs)){if(key.startsWith('on')){continue;}const oldValue=oldAttrs[key];if(key==='style'){if(typeof value==='object'){const oldStyle=typeof oldValue==='object'?oldValue:{};for(const[prop,val]of Object.entries(value)){if(oldStyle[prop]!==val){element.style.setProperty(prop,val);updated=true;}}
for(const prop of Object.keys(oldStyle)){if(!(prop in value)){element.style.removeProperty(prop);updated=true;}}}else if(typeof value==='string'&&oldValue!==value){element.setAttribute('style',value);updated=true;}}else if(key==='class'||key==='className'){if(element.className!==value){element.className=value;updated=true;}}else if(key==='value'&&'value'in element){if(element.value!==value){element.value=value;updated=true;}}else if(key==='checked'&&'checked'in element){if(element.checked!==value){element.checked=value;updated=true;}}else if(key==='disabled'||key==='readonly'||key==='hidden'){if(value){if(!element.hasAttribute(key)){element.setAttribute(key,'');updated=true;}}else{if(element.hasAttribute(key)){element.removeAttribute(key);updated=true;}}}else if(oldValue!==value){if(value===null||value===undefined||value===false){element.removeAttribute(key);}else{element.setAttribute(key,value===true?'':String(value));}updated=true;}}return updated;},patchChildren(parent,oldChildren,newChildren){let updated=false;const oldKeyMap=new Map();const oldNodes=Array.from(parent.childNodes);oldChildren.forEach((child,index)=>{const key=child.key!==undefined?child.key:index;oldKeyMap.set(key,{vnode:child,node:oldNodes[index],index});});const usedOldNodes=new Set();newChildren.forEach((newChild,newIndex)=>{const key=newChild.key!==undefined?newChild.key:newIndex;const old=oldKeyMap.get(key);if(old){usedOldNodes.add(key);const patchResult=this.patch(old.node,old.vnode,newChild);updated=updated||patchResult.updated;const currentNode=parent.childNodes[newIndex];if(currentNode!==old.node){parent.insertBefore(old.node,currentNode||null);updated=true;}}else{const newNode=this.create(newChild);const refNode=parent.childNodes[newIndex];parent.insertBefore(newNode,refNode||null);updated=true;}});for(const[key,old]of oldKeyMap){if(!usedOldNodes.has(key)&&old.node&&old.node.parentNode===parent){parent.removeChild(old.node);updated=true;}}return updated;},create(vnode){if(vnode.type==='text'){return document.createTextNode(vnode.value);}const element=document.createElement(vnode.tag);for(const[key,value]of Object.entries(vnode.attrs||{})){if(key.startsWith('on')){const eventName=key.slice(2).toLowerCase();element.addEventListener(eventName,value);}else if(key==='style'&&typeof value==='object'){for(const[prop,val]of Object.entries(value)){element.style.setProperty(prop,val);}}else if(key==='class'||key==='className'){element.className=value;}else if(value!==null&&value!==undefined&&value!==false){element.setAttribute(key,value===true?'':String(value));}}
for(const child of vnode.children||[]){element.appendChild(this.create(child));}return element;},patch(node,oldVnode,newVnode){if(oldVnode.type!==newVnode.type){const newNode=this.create(newVnode);node.parentNode.replaceChild(newNode,node);return{node:newNode,updated:true};}
if(newVnode.type==='text'){const updated=this.patchText(node,newVnode.value);return{node,updated};}
if(oldVnode.tag!==newVnode.tag){const newNode=this.create(newVnode);node.parentNode.replaceChild(newNode,node);return{node:newNode,updated:true};}
const attrsUpdated=this.patchAttrs(node,oldVnode.attrs||{},newVnode.attrs||{});const childrenUpdated=this.patchChildren(node,oldVnode.children||[],newVnode.children||[]);return{node,updated:attrsUpdated||childrenUpdated};}};const reactiveDOM={bindText(signal,textNode){return reactivity.createEffect(()=>{const value=signal.get();vdom.patchText(textNode,value);});},bindAttribute(signal,element,attrName){let oldValue=undefined;return reactivity.createEffect(()=>{const newValue=signal.get();if(oldValue!==newValue){if(newValue===null||newValue===undefined||newValue===false){element.removeAttribute(attrName);}else{element.setAttribute(attrName,newValue===true?'':String(newValue));}oldValue=newValue;}});},bindStyle(signal,element,property){let oldValue=undefined;return reactivity.createEffect(()=>{const newValue=signal.get();if(oldValue!==newValue){element.style.setProperty(property,newValue);oldValue=newValue;}});},bindClass(signal,element,className){return reactivity.createEffect(()=>{const active=signal.get();if(active){element.classList.add(className);}else{element.classList.remove(className);}});},bindList(signal,parent,renderItem){let oldVnodes=[];return reactivity.createEffect(()=>{const items=signal.get();const newVnodes=items.map((item,index)=>{const vnode=renderItem(item,index);vnode.key=item.key!==undefined?item.key:(item.id!==undefined?item.id:index);return vnode;});vdom.patchChildren(parent,oldVnodes,newVnodes);oldVnodes=newVnodes;});},mount(container,render){let oldVnode=null;let rootNode=null;return reactivity.createEffect(()=>{const newVnode=render();if(oldVnode===null){rootNode=vdom.create(newVnode);container.appendChild(rootNode);}else{const result=vdom.patch(rootNode,oldVnode,newVnode);rootNode=result.node;}oldVnode=newVnode;});}};const reactivityInterface={createSignal(valuePtr,valueLen){const initialValue=valuePtr&&valueLen>0?readString(valuePtr,valueLen):null;const signal=reactivity.createSignal(initialValue);return elementHandles.alloc(signal);},getSignal(signalHandle,outPtr,outLen){const signal=elementHandles.get(signalHandle);if(signal&&signal.get){const value=signal.get();if(value!==null&&value!==undefined){return writeString(String(value),outPtr,outLen);}}return-1;},setSignal(signalHandle,valuePtr,valueLen){const signal=elementHandles.get(signalHandle);if(signal&&signal.set){const value=valuePtr&&valueLen>0?readString(valuePtr,valueLen):null;signal.set(value);}},createComputed(getterPtr){const computed=reactivity.createComputed(()=>{if(wasmInstance&&wasmInstance.exports.__rsc_call_getter){return wasmInstance.exports.__rsc_call_getter(getterPtr);}return null;});return elementHandles.alloc(computed);},getComputed(computedHandle,outPtr,outLen){const computed=elementHandles.get(computedHandle);if(computed&&computed.get){const value=computed.get();if(value!==null&&value!==undefined){return writeString(String(value),outPtr,outLen);}}return-1;},createEffect(effectPtr){const cleanup=reactivity.createEffect(()=>{if(wasmInstance&&wasmInstance.exports.__rsc_call_effect){wasmInstance.exports.__rsc_call_effect(effectPtr);}});return elementHandles.alloc({cleanup});},disposeEffect(effectHandle){const effect=elementHandles.get(effectHandle);if(effect&&effect.cleanup){effect.cleanup();}elementHandles.free(effectHandle);},startBatch(){reactivity.startBatch();},endBatch(){reactivity.endBatch();},bindText(signalHandle,nodeHandle){const signal=elementHandles.get(signalHandle);const node=elementHandles.get(nodeHandle);if(signal&&node){const cleanup=reactiveDOM.bindText(signal,node);return elementHandles.alloc({cleanup});}return 0;},bindAttribute(signalHandle,elementHandle,attrPtr,attrLen){const signal=elementHandles.get(signalHandle);const element=elementHandles.get(elementHandle);const attrName=readString(attrPtr,attrLen);if(signal&&element){const cleanup=reactiveDOM.bindAttribute(signal,element,attrName);return elementHandles.alloc({cleanup});}return 0;},bindStyle(signalHandle,elementHandle,propPtr,propLen){const signal=elementHandles.get(signalHandle);const element=elementHandles.get(elementHandle);const property=readString(propPtr,propLen);if(signal&&element){const cleanup=reactiveDOM.bindStyle(signal,element,property);return elementHandles.alloc({cleanup});}return 0;},bindClass(signalHandle,elementHandle,classPtr,classLen){const signal=elementHandles.get(signalHandle);const element=elementHandles.get(elementHandle);const className=readString(classPtr,classLen);if(signal&&element){const cleanup=reactiveDOM.bindClass(signal,element,className);return elementHandles.alloc({cleanup});}return 0;},disposeBinding(bindingHandle){const binding=elementHandles.get(bindingHandle);if(binding&&binding.cleanup){binding.cleanup();}elementHandles.free(bindingHandle);},flush(){reactivity.flush();}};class EffectSystem{constructor(){this.effects=new Map();this.currentEffect=null;this.pendingEffects=new Set();this.isFlushing=false;this.nextEffectId=1;this.componentEffects=new Map();}runEffect(effectFn,explicitDeps=null){const effectId=this.nextEffectId++;const effectState={id:effectId,fn:effectFn,cleanup:null,dependencies:new Set(),
explicitDeps:explicitDeps,
disposed:false};this.effects.set(effectId,effectState);this._executeEffect(effectId);return effectId;}_executeEffect(effectId){const effectState=this.effects.get(effectId);if(!effectState||effectState.disposed)return;if(effectState.cleanup){this._runCleanup(effectState);}
if(!effectState.explicitDeps){effectState.dependencies.clear();}
const prevEffect=this.currentEffect;this.currentEffect=effectId;try{let result;if(typeof effectState.fn==='function'){result=effectState.fn();}else if(wasmInstance&&wasmInstance.exports.__rsc_call_effect){result=wasmInstance.exports.__rsc_call_effect(effectState.fn);}
if(typeof result==='function'){effectState.cleanup=result;}else if(typeof result==='number'&&result!==0){effectState.cleanup=result;}}catch(error){console.error(`Effect ${effectId} execution error:`,error);}finally{this.currentEffect=prevEffect;}}trackDependency(signalId){if(this.currentEffect===null)return;const effectState=this.effects.get(this.currentEffect);if(!effectState||effectState.explicitDeps)return;effectState.dependencies.add(signalId);}notifySignalChange(signalId){for(const[effectId,effectState]of this.effects){if(effectState.disposed)continue;const deps=effectState.explicitDeps||effectState.dependencies;if(deps.has(signalId)){this.pendingEffects.add(effectId);}}
if(!this.isFlushing&&this.pendingEffects.size>0){this.isFlushing=true;queueMicrotask(()=>this._flushEffects());}}_flushEffects(){const effects=Array.from(this.pendingEffects);this.pendingEffects.clear();this.isFlushing=false;for(const effectId of effects){this._executeEffect(effectId);}}_runCleanup(effectState){if(!effectState.cleanup)return;try{if(typeof effectState.cleanup==='function'){effectState.cleanup();}else if(wasmInstance&&wasmInstance.exports.__rsc_call_cleanup){wasmInstance.exports.__rsc_call_cleanup(effectState.cleanup);}}catch(error){console.error(`Effect cleanup error:`,error);}effectState.cleanup=null;}cleanupEffect(effectId){const effectState=this.effects.get(effectId);if(!effectState)return;this._runCleanup(effectState);effectState.dependencies.clear();effectState.disposed=true;this.effects.delete(effectId);this.pendingEffects.delete(effectId);}trackForComponent(componentId,effectId){if(!this.componentEffects.has(componentId)){this.componentEffects.set(componentId,new Set());}this.componentEffects.get(componentId).add(effectId);}disposeComponentEffects(componentId){const effects=this.componentEffects.get(componentId);if(!effects)return;for(const effectId of effects){this.cleanupEffect(effectId);}this.componentEffects.delete(componentId);}getCurrentEffect(){return this.currentEffect;}}
const effectSystem=new EffectSystem();const lifecycleManager={mounts:new Map(),unmounts:new Map(),nextId:1};const lifecycle={onMount(callbackPtr){const id=lifecycleManager.nextId++;lifecycleManager.mounts.set(id,callbackPtr);queueMicrotask(()=>{if(wasmInstance&&wasmInstance.exports.__rsc_call_mount){wasmInstance.exports.__rsc_call_mount(callbackPtr);}});return id;},onUnmount(mountId,cleanupPtr){lifecycleManager.unmounts.set(mountId,cleanupPtr);},
runEffect(effectFnPtr,depsPtr=0,depsLen=0){let explicitDeps=null;if(depsPtr!==0&&depsLen>0&&wasmMemory){const depsArray=new Uint32Array(wasmMemory.buffer,depsPtr,depsLen);explicitDeps=new Set(depsArray);}return effectSystem.runEffect(effectFnPtr,explicitDeps);},createEffect(effectFn){return effectSystem.runEffect(effectFn,null);},cleanupEffect(effectId){effectSystem.cleanupEffect(effectId);},trackEffect(componentId,effectId){effectSystem.trackForComponent(componentId,effectId);},trackSignalRead(signalId){effectSystem.trackDependency(signalId);},notifySignalChange(signalId){effectSystem.notifySignalChange(signalId);},getCurrentEffect(){return effectSystem.getCurrentEffect();},disposeComponent(componentId){effectSystem.disposeComponentEffects(componentId);const cleanup=lifecycleManager.unmounts.get(componentId);if(cleanup&&wasmInstance&&wasmInstance.exports.__rsc_call_cleanup){wasmInstance.exports.__rsc_call_cleanup(cleanup);}lifecycleManager.unmounts.delete(componentId);lifecycleManager.mounts.delete(componentId);},
registerEffect(effectPtr,depsPtr,depsLen){return this.runEffect(effectPtr,depsPtr,depsLen);}};const components={create(renderFnPtr,propsPtr,parentHandle){return componentManager.create(renderFnPtr,propsPtr,parentHandle);},update(componentId,propsPtr){return componentManager.update(componentId,propsPtr)?1:0;},unmount(componentId){return componentManager.unmount(componentId)?1:0;},count(){return componentManager.count();},exists(componentId){return componentManager.get(componentId)?1:0;},getElement(componentId){const instance=componentManager.get(componentId);if(instance&&instance.element){return elementHandles.alloc(instance.element);}return 0;},addChild(parentId,childId){componentManager.addChild(parentId,childId);},
pushBoundary(componentId,fallbackPtr){errorBoundary.push(componentId,fallbackPtr||null);},popBoundary(){errorBoundary.pop();},hasError(componentId){return errorBoundary.hasError(componentId)?1:0;},clearError(componentId){errorBoundary.clearError(componentId);},setErrorHandler(handlerPtr){if(handlerPtr){errorBoundary.setGlobalErrorHandler((error,componentId)=>{if(wasmInstance&&wasmInstance.exports.__rsc_handle_component_error){wasmInstance.exports.__rsc_handle_component_error(handlerPtr,componentId||0,error.message||'Unknown error');}});}else{errorBoundary.setGlobalErrorHandler(null);}}};const bindings={bindValue(elementHandle,signalHandle,eventTypePtr,eventTypeLen){const element=elementHandles.get(elementHandle);const signal=elementHandles.get(signalHandle);if(!element||!signal){console.warn('[RustScript Bindings] Invalid element or signal handle');return;}const eventType=eventTypePtr&&eventTypeLen>0?readString(eventTypePtr,eventTypeLen):'input';const initialValue=signal.get();if(initialValue!==null&&initialValue!==undefined){element.value=String(initialValue);}
const handleDomChange=(e)=>{const newValue=e.target.value;if(signal.get()!==newValue){signal.set(newValue);}};element.addEventListener(eventType,handleDomChange);const cleanup=reactivity.createEffect(()=>{const newValue=signal.get();if(element.value!==String(newValue!==null&&newValue!==undefined?newValue:'')){element.value=newValue!==null&&newValue!==undefined?String(newValue):'';}});return{cleanup:()=>{element.removeEventListener(eventType,handleDomChange);cleanup();}};},bindChecked(elementHandle,signalHandle){const element=elementHandles.get(elementHandle);const signal=elementHandles.get(signalHandle);if(!element||!signal){console.warn('[RustScript Bindings] Invalid element or signal handle');return;}
const initialValue=signal.get();element.checked=Boolean(initialValue);const handleDomChange=(e)=>{const newValue=e.target.checked;if(signal.get()!==newValue){signal.set(newValue);}};element.addEventListener('change',handleDomChange);const cleanup=reactivity.createEffect(()=>{const newValue=signal.get();if(element.checked!==Boolean(newValue)){element.checked=Boolean(newValue);}});return{cleanup:()=>{element.removeEventListener('change',handleDomChange);cleanup();}};},bindSelect(elementHandle,signalHandle){const element=elementHandles.get(elementHandle);const signal=elementHandles.get(signalHandle);if(!element||!signal){console.warn('[RustScript Bindings] Invalid element or signal handle');return;}
const initialValue=signal.get();if(initialValue!==null&&initialValue!==undefined){element.value=String(initialValue);}
const handleDomChange=(e)=>{const newValue=e.target.value;if(signal.get()!==newValue){signal.set(newValue);}};element.addEventListener('change',handleDomChange);const cleanup=reactivity.createEffect(()=>{const newValue=signal.get();const stringValue=newValue!==null&&newValue!==undefined?String(newValue):'';if(element.value!==stringValue){element.value=stringValue;}});return{cleanup:()=>{element.removeEventListener('change',handleDomChange);cleanup();}};}};const conditionals={instances:new Map(),nextHandle:1,create(parentHandle){const handle=this.nextHandle++;let parent;if(parentHandle&&parentHandle!==0){parent=elementHandles.get(parentHandle);}if(!parent){parent=document.body;}
const placeholder=document.createComment(`@if ${handle}`);parent.appendChild(placeholder);this.instances.set(handle,{placeholder,parent,currentCondition:null,currentContent:[],trueFn:null,falseFn:null,subscribed:false});elementHandles.alloc(placeholder);return handle;},update(placeholderHandle,condition,trueFnId,falseFnId){const instance=this.instances.get(placeholderHandle);if(!instance){console.warn(`[RustScript Conditionals] Unknown placeholder: ${placeholderHandle}`);return;}const boolCondition=condition!==0;instance.trueFn=trueFnId;instance.falseFn=falseFnId;if(instance.currentCondition===boolCondition&&instance.subscribed){return;}instance.currentCondition=boolCondition;instance.subscribed=true;this.clearContent(instance);const renderFnId=boolCondition?trueFnId:falseFnId;if(renderFnId&&renderFnId!==0){this.renderBranch(instance,renderFnId);}},clear(placeholderHandle){const instance=this.instances.get(placeholderHandle);if(!instance){return;}
this.clearContent(instance);if(instance.placeholder&&instance.placeholder.parentNode){instance.placeholder.parentNode.removeChild(instance.placeholder);}
this.instances.delete(placeholderHandle);},clearContent(instance){for(const node of instance.currentContent){if(node&&node.parentNode){node.parentNode.removeChild(node);}}instance.currentContent=[];},renderBranch(instance,renderFnId){if(wasmInstance&&wasmInstance.exports.__rsc_call_render){try{const resultHandle=wasmInstance.exports.__rsc_call_render(renderFnId);const element=elementHandles.get(resultHandle);if(element){const nextSibling=instance.placeholder.nextSibling;if(nextSibling){instance.parent.insertBefore(element,nextSibling);}else{instance.parent.appendChild(element);}instance.currentContent.push(element);}}catch(e){console.error('[RustScript Conditionals] Error rendering branch:',e);}}}};const conditionalsInterface={create(parentHandle){return conditionals.create(parentHandle);},update(placeholder,condition,trueFn,falseFn){conditionals.update(placeholder,condition,trueFn,falseFn);},clear(placeholder){conditionals.clear(placeholder);}};const signalRuntime={signals:new Map(),nextHandle:1,currentContext:null,subscribers:new Map(),pendingNotifications:new Set(),batchDepth:0,create(initialValue){const handle=this.nextHandle++;this.signals.set(handle,{value:initialValue,
dependents:new Set()});this.subscribers.set(handle,new Set());return handle;},get(handle){const signal=this.signals.get(handle);if(!signal){console.warn(`[Signal Runtime] Unknown signal handle: ${handle}`);return 0;}
if(this.currentContext!==null){signal.dependents.add(this.currentContext);reactivity.track(handle);}return signal.value;},set(handle,value){const signal=this.signals.get(handle);if(!signal){console.warn(`[Signal Runtime] Unknown signal handle: ${handle}`);return;}
if(signal.value===value){return;}const oldValue=signal.value;signal.value=value;const subs=this.subscribers.get(handle);if(subs&&subs.size>0){if(this.batchDepth>0){for(const callback of subs){this.pendingNotifications.add(()=>{try{callback(value,oldValue);}catch(e){console.error('[Signal Runtime] Subscriber error:',e);}});}}else{for(const callback of subs){try{callback(value,oldValue);}catch(e){console.error('[Signal Runtime] Subscriber error:',e);}}}}
reactivity.trigger(handle);},subscribe(handle,callbackPtr){const signal=this.signals.get(handle);if(!signal){console.warn(`[Signal Runtime] Unknown signal handle: ${handle}`);return 0;}
let callback;if(typeof callbackPtr==='function'){callback=callbackPtr;}else{callback=(newValue,oldValue)=>{if(wasmInstance&&wasmInstance.exports.__rsc_call_signal_subscriber){wasmInstance.exports.__rsc_call_signal_subscriber(callbackPtr,newValue,oldValue);}};}
const subscriptionId=this.nextHandle++;callback._subscriptionId=subscriptionId;const subs=this.subscribers.get(handle);if(subs){subs.add(callback);}
return subscriptionId;},unsubscribe(handle,subscriptionId){const subs=this.subscribers.get(handle);if(subs){for(const callback of subs){if(callback._subscriptionId===subscriptionId){subs.delete(callback);break;}}}},startBatch(){this.batchDepth++;},endBatch(){this.batchDepth--;if(this.batchDepth===0&&this.pendingNotifications.size>0){const notifications=Array.from(this.pendingNotifications);this.pendingNotifications.clear();for(const notify of notifications){notify();}}},runInContext(fn,updater){const prevContext=this.currentContext;this.currentContext=updater;try{return fn();}finally{this.currentContext=prevContext;}},dispose(handle){this.signals.delete(handle);this.subscribers.delete(handle);}};const signals={signalCreate(initialValue){return signalRuntime.create(initialValue);},signalGet(handle){return signalRuntime.get(handle);},signalSet(handle,value){signalRuntime.set(handle,value);},signalSubscribe(handle,callbackPtr){return signalRuntime.subscribe(handle,callbackPtr);}};const lists={instances:new Map(),nextHandle:1,create(parentElement){const parent=typeof parentElement==='number'?elementHandles.get(parentElement):parentElement;if(!parent&&parentElement!==0){console.warn('List create: parent element not found');}
const placeholder=document.createComment('list-placeholder');const actualParent=parent||document.body;actualParent.appendChild(placeholder);const handle=this.nextHandle++;this.instances.set(handle,{placeholder:placeholder,parent:actualParent,items:[],keys:[],elements:new Map(),
renderFn:null,keyFn:null});return elementHandles.alloc(placeholder);},update(placeholderHandle,itemsPtr,itemsLen,keyFnPtr,renderFnPtr){const placeholder=elementHandles.get(placeholderHandle);if(!placeholder){console.warn('List update: placeholder not found');return;}
let instance=null;for(const[handle,inst]of this.instances){if(inst.placeholder===placeholder||elementHandles.get(handle)===placeholder){instance=inst;break;}}if(!instance){console.warn('List update: instance not found for placeholder');return;}
const newItems=this._deserializeItems(itemsPtr,itemsLen);const newKeys=newItems.map((item,index)=>{if(keyFnPtr&&keyFnPtr!==0){return this._callKeyFn(keyFnPtr,item,index);}
return String(index);});const oldKeyToElement=new Map(instance.elements);const processedKeys=new Set();const newElements=[];for(let i=0;i<newItems.length;i++){const item=newItems[i];const key=newKeys[i];processedKeys.add(key);if(oldKeyToElement.has(key)){const element=oldKeyToElement.get(key);if(renderFnPtr&&renderFnPtr!==0){this._updateElement(element,item,i,renderFnPtr);}newElements.push({key,element});}else{const element=this._createElement(item,i,renderFnPtr);newElements.push({key,element});}}
for(const[key,element]of oldKeyToElement){if(!processedKeys.has(key)){if(element&&element.parentNode){element.parentNode.removeChild(element);}}}
this._reorderElements(instance.parent,instance.placeholder,newElements);instance.items=newItems;instance.keys=newKeys;instance.elements=new Map(newElements.map(e=>[e.key,e.element]));},clear(placeholderHandle){const placeholder=elementHandles.get(placeholderHandle);if(!placeholder){return;}
for(const[handle,instance]of this.instances){if(instance.placeholder===placeholder||elementHandles.get(handle)===placeholder){for(const element of instance.elements.values()){if(element&&element.parentNode){element.parentNode.removeChild(element);}}
instance.items=[];instance.keys=[];instance.elements=new Map();break;}}},_deserializeItems(ptr,len){if(!ptr||len===0){return[];}
try{if(wasmMemory){const view=new Uint32Array(wasmMemory.buffer,ptr,len);return Array.from(view);}}catch(e){console.warn('Failed to deserialize items:',e);}return[];},_callKeyFn(keyFnPtr,item,index){if(wasmInstance&&wasmInstance.exports.__rsc_call_key_fn){try{return String(wasmInstance.exports.__rsc_call_key_fn(keyFnPtr,item,index));}catch(e){console.warn('Key function error:',e);}}return String(index);},_createElement(item,index,renderFnPtr){const element=document.createElement('div');element.setAttribute('data-list-item',String(index));if(renderFnPtr&&renderFnPtr!==0&&wasmInstance){if(wasmInstance.exports.__rsc_call_render_item){try{const contentHandle=wasmInstance.exports.__rsc_call_render_item(renderFnPtr,item,index);const content=elementHandles.get(contentHandle);if(content){element.appendChild(content);}}catch(e){console.warn('Render item error:',e);element.textContent=String(item);}}else{element.textContent=String(item);}}else{element.textContent=String(item);}return element;},_updateElement(element,item,index,renderFnPtr){element.setAttribute('data-list-item',String(index));if(!renderFnPtr||renderFnPtr===0){element.textContent=String(item);}
},_reorderElements(parent,placeholder,newElements){let insertBefore=placeholder.nextSibling;for(const{element}of newElements){if(!element)continue;if(element.nextSibling!==insertBefore){if(insertBefore){parent.insertBefore(element,insertBefore);}else{parent.appendChild(element);}}
insertBefore=element.nextSibling;}}};const effects={cleanup(effectId){effectSystem.cleanupEffect(effectId);},disposeAll(componentId){effectSystem.disposeComponentEffects(componentId);}};const convert={i32ToString(value){const str=String(value);const textNode=document.createTextNode(str);return elementHandles.alloc(textNode);},f64ToString(value){const str=String(value);const textNode=document.createTextNode(str);return elementHandles.alloc(textNode);}};function createImports(){return{'rustscript:web/dom':dom,'rustscript:web/lists':lists,'rustscript:web/conditionals':conditionalsInterface,'rustscript:web/events':events,'rustscript:web/console':consoleApi,'rustscript:web/timers':timers,'rustscript:web/storage':storage,'rustscript:web/http':http,'rustscript:router/router':router,'rustscript:web/lifecycle':lifecycle,'rustscript:web/components':components,'rustscript:web/reactivity':reactivityInterface,'rustscript:web/bindings':bindings,'rustscript:web/signals':signals,'rustscript:web/convert':convert,'rustscript:web/effects':effects,};}function initialize(instance,memory){wasmInstance=instance;wasmMemory=memory;if(instance.exports.init){instance.exports.init();}}async function loadApp(wasmSource,rootId='app'){let wasmBytes;if(typeof wasmSource==='string'){const response=await fetch(wasmSource);wasmBytes=await response.arrayBuffer();}else{wasmBytes=wasmSource;}const imports=createImports();const{instance}=await WebAssembly.instantiate(wasmBytes,imports);const memory=instance.exports.memory;initialize(instance,memory);if(instance.exports.mount){const SCRATCH_BUFFER_OFFSET=65536;const encoder=new TextEncoder();const rootIdBytes=encoder.encode(rootId);const rootIdPtr=SCRATCH_BUFFER_OFFSET;const rootIdLen=rootIdBytes.length;const view=new Uint8Array(memory.buffer,rootIdPtr,rootIdLen);view.set(rootIdBytes);const result=instance.exports.mount(rootIdPtr,rootIdLen);if(result!==0){throw new Error(`Failed to mount app: error code ${result}`);}}return{instance,memory,unmount:()=>{if(instance.exports.unmount){instance.exports.unmount();}}};}
const RustScript={createImports,initialize,loadApp,
elementHandles,eventHandlerHandles,timerHandles,
dom,events,console:consoleApi,timers,storage,http,router,lifecycle,components,
componentManager,
errorBoundary,
reactivity,vdom,reactiveDOM,reactivityInterface,
effectSystem,
bindings,
signalRuntime,signals,
lists,
conditionals,conditionalsInterface,};if(typeof module!=='undefined'&&module.exports){module.exports=RustScript;}else{global.RustScript=RustScript;}})(typeof globalThis!=='undefined'?globalThis:typeof window!=='undefined'?window:this);