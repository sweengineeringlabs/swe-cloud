//! Mock client for Azure Blob Storage.
//!
//! Generated by `rsc scaffold services`

use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use crate::api::azure::blobs::*;

/// Mock implementation of BlobsClient for testing.
#[derive(Clone, Default)]
pub struct BlobsClientMock {
    responses: Arc<Mutex<HashMap<String, String>>>,
    calls: Arc<Mutex<Vec<String>>>,
}

impl BlobsClientMock {
    /// Create a new mock client.
    pub fn new() -> Self {
        Self::default()
    }

    /// Set a canned response for an operation.
    pub fn with_response<T: serde::Serialize>(mut self, operation: &str, response: T) -> Self {
        let json = serde_json::to_string(&response).unwrap_or_default();
        self.responses.lock().unwrap().insert(operation.to_string(), json);
        self
    }

    /// Get all recorded calls.
    pub fn calls(&self) -> Vec<String> {
        self.calls.lock().unwrap().clone()
    }

    /// Check if an operation was called.
    pub fn was_called(&self, operation: &str) -> bool {
        self.calls.lock().unwrap().iter().any(|c| c == operation)
    }

    /// Get the number of times an operation was called.
    pub fn call_count(&self, operation: &str) -> usize {
        self.calls.lock().unwrap().iter().filter(|c| *c == operation).count()
    }

    /// Mock CreateContainer operation.
    pub async fn create_container(&self, _request: CreateContainerRequest) -> Result<CreateContainerResponse, String> {
        self.calls.lock().unwrap().push("CreateContainer".to_string());

        if let Some(response) = self.responses.lock().unwrap().get("CreateContainer") {
            serde_json::from_str(response).map_err(|e| e.to_string())
        } else {
            Ok(CreateContainerResponse::default())
        }
    }

    /// Mock DeleteContainer operation.
    pub async fn delete_container(&self, _request: DeleteContainerRequest) -> Result<DeleteContainerResponse, String> {
        self.calls.lock().unwrap().push("DeleteContainer".to_string());

        if let Some(response) = self.responses.lock().unwrap().get("DeleteContainer") {
            serde_json::from_str(response).map_err(|e| e.to_string())
        } else {
            Ok(DeleteContainerResponse::default())
        }
    }

    /// Mock ListContainers operation.
    pub async fn list_containers(&self, _request: ListContainersRequest) -> Result<ListContainersResponse, String> {
        self.calls.lock().unwrap().push("ListContainers".to_string());

        if let Some(response) = self.responses.lock().unwrap().get("ListContainers") {
            serde_json::from_str(response).map_err(|e| e.to_string())
        } else {
            Ok(ListContainersResponse::default())
        }
    }

    /// Mock UploadBlob operation.
    pub async fn upload_blob(&self, _request: UploadBlobRequest) -> Result<UploadBlobResponse, String> {
        self.calls.lock().unwrap().push("UploadBlob".to_string());

        if let Some(response) = self.responses.lock().unwrap().get("UploadBlob") {
            serde_json::from_str(response).map_err(|e| e.to_string())
        } else {
            Ok(UploadBlobResponse::default())
        }
    }

    /// Mock DownloadBlob operation.
    pub async fn download_blob(&self, _request: DownloadBlobRequest) -> Result<DownloadBlobResponse, String> {
        self.calls.lock().unwrap().push("DownloadBlob".to_string());

        if let Some(response) = self.responses.lock().unwrap().get("DownloadBlob") {
            serde_json::from_str(response).map_err(|e| e.to_string())
        } else {
            Ok(DownloadBlobResponse::default())
        }
    }

    /// Mock DeleteBlob operation.
    pub async fn delete_blob(&self, _request: DeleteBlobRequest) -> Result<DeleteBlobResponse, String> {
        self.calls.lock().unwrap().push("DeleteBlob".to_string());

        if let Some(response) = self.responses.lock().unwrap().get("DeleteBlob") {
            serde_json::from_str(response).map_err(|e| e.to_string())
        } else {
            Ok(DeleteBlobResponse::default())
        }
    }

    /// Mock ListBlobs operation.
    pub async fn list_blobs(&self, _request: ListBlobsRequest) -> Result<ListBlobsResponse, String> {
        self.calls.lock().unwrap().push("ListBlobs".to_string());

        if let Some(response) = self.responses.lock().unwrap().get("ListBlobs") {
            serde_json::from_str(response).map_err(|e| e.to_string())
        } else {
            Ok(ListBlobsResponse::default())
        }
    }

}
