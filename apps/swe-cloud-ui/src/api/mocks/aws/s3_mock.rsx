//! Mock client for Aws S3.
//!
//! Generated by `rsc scaffold services`

use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use crate::api::aws::s3::*;

/// Mock implementation of S3Client for testing.
#[derive(Clone, Default)]
pub struct S3ClientMock {
    responses: Arc<Mutex<HashMap<String, String>>>,
    calls: Arc<Mutex<Vec<String>>>,
}

impl S3ClientMock {
    /// Create a new mock client.
    pub fn new() -> Self {
        Self::default()
    }

    /// Set a canned response for an operation.
    pub fn with_response<T: serde::Serialize>(mut self, operation: &str, response: T) -> Self {
        let json = serde_json::to_string(&response).unwrap_or_default();
        self.responses.lock().unwrap().insert(operation.to_string(), json);
        self
    }

    /// Get all recorded calls.
    pub fn calls(&self) -> Vec<String> {
        self.calls.lock().unwrap().clone()
    }

    /// Check if an operation was called.
    pub fn was_called(&self, operation: &str) -> bool {
        self.calls.lock().unwrap().iter().any(|c| c == operation)
    }

    /// Get the number of times an operation was called.
    pub fn call_count(&self, operation: &str) -> usize {
        self.calls.lock().unwrap().iter().filter(|c| *c == operation).count()
    }

    /// Mock CreateBucket operation.
    pub async fn create_bucket(&self, _request: CreateBucketRequest) -> Result<CreateBucketResponse, String> {
        self.calls.lock().unwrap().push("CreateBucket".to_string());

        if let Some(response) = self.responses.lock().unwrap().get("CreateBucket") {
            serde_json::from_str(response).map_err(|e| e.to_string())
        } else {
            Ok(CreateBucketResponse::default())
        }
    }

    /// Mock DeleteBucket operation.
    pub async fn delete_bucket(&self, _request: DeleteBucketRequest) -> Result<DeleteBucketResponse, String> {
        self.calls.lock().unwrap().push("DeleteBucket".to_string());

        if let Some(response) = self.responses.lock().unwrap().get("DeleteBucket") {
            serde_json::from_str(response).map_err(|e| e.to_string())
        } else {
            Ok(DeleteBucketResponse::default())
        }
    }

    /// Mock ListBuckets operation.
    pub async fn list_buckets(&self, _request: ListBucketsRequest) -> Result<ListBucketsResponse, String> {
        self.calls.lock().unwrap().push("ListBuckets".to_string());

        if let Some(response) = self.responses.lock().unwrap().get("ListBuckets") {
            serde_json::from_str(response).map_err(|e| e.to_string())
        } else {
            Ok(ListBucketsResponse::default())
        }
    }

    /// Mock PutObject operation.
    pub async fn put_object(&self, _request: PutObjectRequest) -> Result<PutObjectResponse, String> {
        self.calls.lock().unwrap().push("PutObject".to_string());

        if let Some(response) = self.responses.lock().unwrap().get("PutObject") {
            serde_json::from_str(response).map_err(|e| e.to_string())
        } else {
            Ok(PutObjectResponse::default())
        }
    }

    /// Mock GetObject operation.
    pub async fn get_object(&self, _request: GetObjectRequest) -> Result<GetObjectResponse, String> {
        self.calls.lock().unwrap().push("GetObject".to_string());

        if let Some(response) = self.responses.lock().unwrap().get("GetObject") {
            serde_json::from_str(response).map_err(|e| e.to_string())
        } else {
            Ok(GetObjectResponse::default())
        }
    }

    /// Mock DeleteObject operation.
    pub async fn delete_object(&self, _request: DeleteObjectRequest) -> Result<DeleteObjectResponse, String> {
        self.calls.lock().unwrap().push("DeleteObject".to_string());

        if let Some(response) = self.responses.lock().unwrap().get("DeleteObject") {
            serde_json::from_str(response).map_err(|e| e.to_string())
        } else {
            Ok(DeleteObjectResponse::default())
        }
    }

    /// Mock ListObjects operation.
    pub async fn list_objects(&self, _request: ListObjectsRequest) -> Result<ListObjectsResponse, String> {
        self.calls.lock().unwrap().push("ListObjects".to_string());

        if let Some(response) = self.responses.lock().unwrap().get("ListObjects") {
            serde_json::from_str(response).map_err(|e| e.to_string())
        } else {
            Ok(ListObjectsResponse::default())
        }
    }

}
